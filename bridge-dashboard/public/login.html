# FastAPI backend for BRidge Buyer Portal - With Postgres + PDF + OpenAPI ready

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
from sqlalchemy import create_engine, Column, String, Float, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
import csv
import base64
import os
import uuid
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader
from io import BytesIO

app = FastAPI(title="BRidge API", description="ICE-ready digital commodities trade + BOL platform.", version="1.0")

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Use Postgres instead of SQLite
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://bridge_user:bridge_pass@localhost/bridge_db")
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# --- SQLAlchemy DB Models ---
class BOL(Base):
    __tablename__ = "bols"
    bol_id = Column(String, primary_key=True, index=True)
    contract_id = Column(String)
    buyer = Column(String)
    seller = Column(String)
    material = Column(String)
    weight_tons = Column(Float)
    price_per_unit = Column(Float)
    total_value = Column(Float)
    carrier_name = Column(String)
    carrier_driver = Column(String)
    carrier_truck_vin = Column(String)
    pickup_signature = Column(Text)
    pickup_time = Column(DateTime)
    delivery_signature = Column(Text, nullable=True)
    delivery_time = Column(DateTime, nullable=True)
    status = Column(String)

class User(Base):
    __tablename__ = "users"
    username = Column(String, primary_key=True)
    password = Column(String)
    role = Column(String)

Base.metadata.create_all(bind=engine)

# Dependency

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- Pydantic Models ---
class CarrierInfo(BaseModel):
    name: str
    driver: str
    truck_vin: str

class Signature(BaseModel):
    base64: str
    timestamp: datetime

class BOLRecord(BaseModel):
    bol_id: str
    contract_id: str
    buyer: str
    seller: str
    material: str
    weight_tons: float
    price_per_unit: float
    total_value: float
    carrier: CarrierInfo
    pickup_signature: Signature
    delivery_signature: Optional[Signature] = None
    pickup_time: datetime
    delivery_time: Optional[datetime] = None
    status: str

class LoginRequest(BaseModel):
    username: str
    password: str

@app.post("/login")
def login(data: LoginRequest, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.username == data.username).first()
    if not user or user.password != data.password:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    return {"message": "Login successful", "role": user.role, "username": user.username}

@app.post("/create_bol")
def create_bol(record: BOLRecord, db: Session = Depends(get_db)):
    new_bol = BOL(
        bol_id=record.bol_id,
        contract_id=record.contract_id,
        buyer=record.buyer,
        seller=record.seller,
        material=record.material,
        weight_tons=record.weight_tons,
        price_per_unit=record.price_per_unit,
        total_value=record.total_value,
        carrier_name=record.carrier.name,
        carrier_driver=record.carrier.driver,
        carrier_truck_vin=record.carrier.truck_vin,
        pickup_signature=record.pickup_signature.base64,
        pickup_time=record.pickup_time,
        delivery_signature=record.delivery_signature.base64 if record.delivery_signature else None,
        delivery_time=record.delivery_time,
        status=record.status
    )
    db.add(new_bol)
    db.commit()
    db.refresh(new_bol)
    return {"message": "BOL created", "bol_id": new_bol.bol_id}

@app.get("/bols")
def get_all_bols(db: Session = Depends(get_db)):
    return db.query(BOL).all()

@app.get("/bol/{bol_id}")
def get_bol_by_id(bol_id: str, db: Session = Depends(get_db)):
    bol = db.query(BOL).filter(BOL.bol_id == bol_id).first()
    if not bol:
        raise HTTPException(status_code=404, detail="BOL not found")
    return bol

@app.post("/update_status/{bol_id}")
def update_status(bol_id: str, new_status: str, db: Session = Depends(get_db)):
    bol = db.query(BOL).filter(BOL.bol_id == bol_id).first()
    if not bol:
        raise HTTPException(status_code=404, detail="BOL not found")
    bol.status = new_status
    if new_status == "Delivered":
        bol.delivery_time = datetime.utcnow()
    db.commit()
    return {"message": "Status updated"}

@app.post("/add_delivery_signature/{bol_id}")
def add_delivery_signature(bol_id: str, signature: Signature, db: Session = Depends(get_db)):
    bol = db.query(BOL).filter(BOL.bol_id == bol_id).first()
    if not bol:
        raise HTTPException(status_code=404, detail="BOL not found")
    bol.delivery_signature = signature.base64
    bol.delivery_time = datetime.utcnow()
    bol.status = "Delivered"
    db.commit()
    return {"message": "Delivery signature added"}

@app.get("/export_csv")
def export_csv(db: Session = Depends(get_db)):
    filename = f"bol_export_{datetime.utcnow().isoformat()}.csv"
    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["BOL_ID", "Contract_ID", "Buyer", "Material", "Weight", "Status", "Pickup_Time", "Delivery_Time", "Total_Value"])
        for r in db.query(BOL).all():
            writer.writerow([
                r.bol_id, r.contract_id, r.buyer, r.material, r.weight_tons, r.status,
                r.pickup_time.isoformat(), r.delivery_time.isoformat() if r.delivery_time else "",
                f"${r.total_value:,.2f}"
            ])
    return {"message": "CSV exported", "filename": filename}

@app.get("/bol_pdf/{bol_id}")
def generate_pdf(bol_id: str, db: Session = Depends(get_db)):
    bol = db.query(BOL).filter(BOL.bol_id == bol_id).first()
    if not bol:
        raise HTTPException(status_code=404, detail="BOL not found")

    pdf_filename = f"bol_{bol_id}.pdf"
    c = canvas.Canvas(pdf_filename, pagesize=letter)
    c.setFont("Helvetica", 12)
    c.drawString(30, 750, f"Bill of Lading: {bol.bol_id}")
    c.drawString(30, 730, f"Contract: {bol.contract_id} | Status: {bol.status}")
    c.drawString(30, 710, f"Buyer: {bol.buyer} | Seller: {bol.seller}")
    c.drawString(30, 690, f"Material: {bol.material} | Weight: {bol.weight_tons} tons")
    c.drawString(30, 670, f"Price per Ton: ${bol.price_per_unit} | Total: ${bol.total_value}")
    c.drawString(30, 650, f"Carrier: {bol.carrier_name}, Driver: {bol.carrier_driver}, VIN: {bol.carrier_truck_vin}")
    c.drawString(30, 630, f"Pickup Time: {bol.pickup_time}")
    c.drawString(30, 610, f"Delivery Time: {bol.delivery_time if bol.delivery_time else 'â€”'}")

    if bol.pickup_signature:
        pickup_image = ImageReader(BytesIO(base64.b64decode(bol.pickup_signature.split(',')[1])))
        c.drawImage(pickup_image, 30, 500, width=150, height=50)
        c.drawString(30, 555, "Pickup Signature")

    if bol.delivery_signature:
        delivery_image = ImageReader(BytesIO(base64.b64decode(bol.delivery_signature.split(',')[1])))
        c.drawImage(delivery_image, 200, 500, width=150, height=50)
        c.drawString(200, 555, "Delivery Signature")

    c.showPage()
    c.save()
    return FileResponse(pdf_filename)
